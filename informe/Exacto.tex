\section{Algoritmo Exacto}

\subsection{Explicación}
\todo[inline]{Aca explicar como funciona el algoritmo}
Basicamente genero todos los subconjuntos y si es clique me quedo con la frontera

\subsection{Pseudocódigo}
\todo[inline]{Agregar las complejidades}

% (Ver notas debajo del pseudocodigo las referencia de significados de las variables)
Referencias de variables globales para el pseudocódigo:
\begin{itemize}
    \item $n$: La cantidad de nodos
    \item $solucion$: Secuencia que contiene la clique solución
    \item $fronteraMax$: El cardinal de la frontera de la clique solución
\end{itemize}

\begin{algorithm}[H]
\begin{algorithmic}
\Function{Resolver}{}
    \State LeerInput()
    \State $solucion \gets \emptyset$
    \State $fronteraMax \gets 0$
    \State GenerarSubconjuntos($\emptyset$, $0$)
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}
\Function{GenerarSubconjuntos}{$conjNodos$, $actual$}
    \If {$actual = n$}

        \If {EsClique($conjNodos$)}
            \State $fronteraActual \gets$ Frontera($conjNodos$)
            \If {$fronteraActual > fronteraMax$}
                \State $fronteraMax \gets fronteraActual$
                \State $solucion \gets conjNodos$
            \EndIf
        \EndIf

    \Else
        \State GenerarSubconjuntos($conjNodos$, $actual + 1$)
        \State GenerarSubconjuntos($conjNodos \cup \{actual\}$, $actual + 1$)
    \EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}
\Function{EsClique}{$conjNodos$}
    \For{$v \in conjNodos$}
        \For{$w \in conjNodos$}
            \If{$(v \neq w) \land (\neg$SonVecinos($v$, $w$)$)$}
                \State return $False$
            \EndIf
        \EndFor
    \EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}
\Function{SonVecinos}{$v1, v2$}
    \For{$w \in vecinos[v1]$}
        \If{$w = v2$}
            \State return $True$
        \EndIf
    \EndFor
    \State return $False$

\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}
\Function{Frontera}{$clique$}
    \State $enClique \gets vector(n, False)$ \Comment Vector con $n$ Falses
    \For {$v \in clique$}
        \State $enClique[v] \gets True$
    \EndFor

    \State $contador \gets 0$
    \For{$v \in clique$}
        \For{$vecino \in vecinos[v]$}
            \If{$\neg enClique[vecino]$}
                \State $contador++$
            \EndIf
        \EndFor
    \EndFor

    \State return $contador$

\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Complejidad}

\begin{itemize}
    \item LeerInput es $O(n^2)$: Leo como máximo todas las aristas posibles.
    \item SonVecinos es $O(n)$: Recorro la lista de adyacencia de un vértice, como mucho tiene $O(n)$ vecinos.
    \item EsClique es $O(n^{3})$: Para cada vértice se recorren todos los demas y se revisa si son vecinos.
    \item Frontera es $O(n^{2})$: Para cada vértice de la clique se revisan todos sus vecinos.
    \item GenerarSubconjuntos es $O(2^{n} * n^{3})$: Hay $O(2^n)$ llamados recursivos (Cada vertice está o no está), y en cada llamado recursivo se revisa si EsClique en $O(n^3)$ y luego su Frontera en $O(n^2)$ ($=$ $O(n^3)$).
\end{itemize}

Para Resolver() se lee el input y luego se llama a GenerarSubconjuntos. La complejidad final es:

$$ O(n^2) + O(2^{n} * n^{3}) = O(2^{n} * n^{3})$$
