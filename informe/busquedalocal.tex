% !TEX root = ./informe.tex
\section{Búsqueda Local}

\subsection{Explicación}


El algoritmo goloso del ítem anterior (desde ahora, $goloso A$) es muy bueno, pero al intentarlo usar con búsqueda local tenemos un problema: no podemos salir del extremo local. Esto es asi porque el $goloso A$ comienza siempre del nodo con mayor cantidad de vecinos, y va agregando a la solucion aquellos que maximizan la frontera.
\todo[inline]{Explicar la idea de que ninguna busqueda local la mejora, por lo que decidimos tomar otro punto de partida para el goloso. Explicar como con este cambio se puede mejorar las soluciones obtenidas, ver peor caso}

\todo[inline]{Contar como funciona busqueda local en general, hablar un poquito de la implementacion}

\subsection{Pseudocódigo}

\begin{algorithm}[H]
\begin{algorithmic}
\Function{Resolver}{$solucion$}
    \State $iteraciones \gets 10$
    \State $fronteraMaxima \gets$ Frontera($solucion$)
    \For{$i \in [1..iteraciones]$ }
        \State $solucionActual \gets$ BusquedaLocal($solucion$)
        \State $fronteraActual \gets$ Frontera($solucionActual$)

        \If{$fronteraActual > fronteraMaxima$}
            \State $fronteraMaxima \gets fronteraActual$
            \State $solucion \gets solucionActual$
        \EndIf
    \EndFor
    \State return $solucion$

\EndFunction
\end{algorithmic}
\end{algorithm}

\todo[inline]{Consideramos la vecindad como swapear, agregar o quitar un nodo. Nos quedamos con la mejor y blah}

\begin{algorithm}[H]
\begin{algorithmic}
\Function{BusquedaLocal}{$solucionInicial$}
    \State $complementoInicial \gets$ Complemento($solucionInicial$) \\

    \State $solucionSwap \gets$ MaximoPorSwap($solucionInicial$, $complementoInicial$)
    \State $fronteraSwap \gets$ Frontera($solucionSwap$) \\

    \State $solucionAdd \gets$ MaximoPorAdd($solucionInicial$, $complementoInicial$)
    \State $fronteraAdd \gets$ Frontera($solucionAdd$) \\

    \State $solucionSub \gets$ MaximoPorSub($solucionInicial$)
    \State $fronteraSub \gets$ Frontera($solucionSub$) \\

    \State $solucionSuprema \gets solucionSwap$
    \State $fronteraSuprema \gets fronteraSwap$ \\

    \If{$fronteraAdd > fronteraSuprema$}
        \State $fronteraSuprema \gets$ $fronteraAdd$
        \State $solucionSuprema \gets$ $solucionAdd$  \\
    \EndIf

    \If{$fronteraSub > fronteraSuprema$}
        \State $fronteraSuprema \gets$ $fronteraSub$
        \State $solucionSuprema \gets$ $solucionSub$ \\
    \EndIf

    \State return $solucionSuprema$
\EndFunction

\end{algorithmic}
\end{algorithm}

\todo[inline]{MaximoPorSwap hace tal y tal cosa}

\begin{algorithm}[H]
\begin{algorithmic}
\Function{MaximoPorSwap}{$solucionInicial$, $complementoInicial$}

    \State $candidatos \gets solucionInicial$
    \State $maxFrontera \gets$ Frontera($solucionInicial$)
    \State $max\_i \gets -1$
    \State $max\_j \gets -1$ \\

    \For{$i \in [0..|solucionInicial|)$}
        \For{$j \in [0..|complementoInicial|)$}

            \State $candidato$[$i$] $\gets complementoInicial$[$j$] \Comment Hacemos swap

            \If{EsClique($candidatos$)}
                \State $fronteraCandidato \gets$ Frontera($candidato$)
                \If{$fronteraCandidato > maxFrontera$}
                    \State $max\_i \gets i$
                    \State $max\_j \gets j$
                    \State $maxFrontera \gets fronteraCandidato$
                \EndIf
            \EndIf

            \State $candidato$[$i$] $\gets solucionInicial$[$j$] \Comment Restauro swap
        \EndFor
    \EndFor

    \If{$max\_i \neq -1$}
        \State $candidato$[$max\_i$] $\gets$ $complementoInicial$[$max\_j$] \Comment Swapeo definitivamente
    \EndIf

    \State return $candidatos$

\EndFunction
\end{algorithmic}
\end{algorithm}

\todo[inline]{MaximoPorSub hace tal y tal cosa}

\begin{algorithm}[H]
\begin{algorithmic}
\Function{MaximoPorSub}{$solucionInicial$}
    \State $candidatos \gets solucionInicial$
    \State $maxFrontera \gets$ Frontera($solucionInicial$)
    \State $max\_c \gets -1$  \\

    \For{$c \in candidatos$}
        \If{EsClique($candidatos - \{c\}$)}
            \State $fronteraCandidato \gets$ Frontera($candidatos - \{c\}$)
            \If{$fronteraCandidato > maxFrontera$}
                \State $max\_c \gets c$
                \State $maxFrontera \gets fronteraCandidato$ \\
            \EndIf
        \EndIf
    \EndFor

    \If{$max\_c \neq -1$}
        \State $candidatos \gets (candidatos - \{max\_c\})$
    \EndIf

    \State return $candidatos$

\EndFunction
\end{algorithmic}
\end{algorithm}

\todo[inline]{MaximoPorAdd hace tal y tal cosa}

\begin{algorithm}[H]
\begin{algorithmic}
\Function{MaximoPorAdd}{$solucionInicial$, $complementoInicial$}

    \State $maxFrontera \gets$ Frontera($solucionInicial$)
    \State $max\_c \gets -1$
    \State $candidatos \gets solucionInicial$  \\

    \For{$c \in complementoInicial$}
        \If{EsClique($candidatos + \{c\}$)}
            \State $fronteraCandidato \gets$ Frontera($candidatos + \{c\}$)
            \If{$fronteraCandidato > maxFrontera$}
                \State $max\_c \gets c$
                \State $maxFrontera \gets fronteraCandidato$ \\
            \EndIf
        \EndIf
    \EndFor

    \If{$max\_c \neq -1$}
        \State $candidatos \gets (candidatos + \{max\_c\})$
    \EndIf

    \State return $candidatos$

\EndFunction
\end{algorithmic}
\end{algorithm}


\todo[inline]{Que es el complemento y como se calcula}

\begin{algorithm}[H]
\begin{algorithmic}
\Function{Complemento}{$solucionInicial$}
\EndFunction
\end{algorithmic}
\end{algorithm}


\subsection{Complejidad}

\subsection{Optimalidad}

\subsection{Experimentación}