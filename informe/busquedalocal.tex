% !TEX root = ./informe.tex
\section{Búsqueda Local}

\subsection{Explicación}


El algoritmo goloso del ítem anterior (desde ahora, $goloso A$) es muy bueno, pero al intentarlo usar con búsqueda local tenemos un problema: no podemos salir del extremo local. Esto es asi porque el $goloso A$ comienza siempre del nodo con mayor cantidad de vecinos, y va agregando a la solucion aquellos que maximizan la frontera.
\todo[inline]{Explicar la idea de que ninguna busqueda local la mejora, por lo que decidimos tomar otro punto de partida para el goloso. Explicar como con este cambio se puede mejorar las soluciones obtenidas, ver peor caso}

\todo[inline]{Contar como funciona busqueda local en general, hablar un poquito de la implementacion}

\subsection{Pseudocódigo}

Las funciones EsClique() y Frontera() no son incluidas aquí por ser inguales a las incluidas previamente. Las complejidades son $O(n^3)$ y $O(n^2)$ respectivamente. \\

\begin{algorithm}[H]
\begin{algorithmic}
\Function{Resolver}{$solucion$, $iteraciones$}          \Comment $O(iteraciones * n^5)$

    \State $fronteraMaxima \gets$ Frontera($solucion$)                      \Comment $O(n^2)$
    \For{$i \in [1..iteraciones]$ }                                         \Comment $O(iteraciones * n^5)$
        \State $solucionActual \gets$ BusquedaLocal($solucion$)             \Comment $O(n^5)$
        \State $fronteraActual \gets$ Frontera($solucionActual$)            \Comment $O(n^2)$

        \If{$fronteraActual > fronteraMaxima$}                              \Comment $O(1)$
            \State $fronteraMaxima \gets fronteraActual$                    \Comment $O(1)$
            \State $solucion \gets solucionActual$                          \Comment $O(1)$
        \EndIf
    \EndFor
    \State return $solucion$

\EndFunction
\end{algorithmic}
\end{algorithm}

\todo[inline]{Consideramos la vecindad como swapear, agregar o quitar un nodo. Nos quedamos con la mejor y blah}

\begin{algorithm}[H]
\begin{algorithmic}
\Function{BusquedaLocal}{$solucionInicial$}             \Comment $O(n^5)$
    \State $complementoInicial \gets$ Complemento($solucionInicial$) \Comment $O(n)$\\

    \State $solucionSwap \gets$ MaximoPorSwap($solucionInicial$, $complementoInicial$)  \Comment $O(n^5)$
    \State $fronteraSwap \gets$ Frontera($solucionSwap$)                                \Comment $O(n^2)$ \\

    \State $solucionAdd \gets$ MaximoPorAdd($solucionInicial$, $complementoInicial$)    \Comment $O(n^4)$
    \State $fronteraAdd \gets$ Frontera($solucionAdd$)                                  \Comment $O(n^2)$\\

    \State $solucionSub \gets$ MaximoPorSub($solucionInicial$)      \Comment $O(n^4)$
    \State $fronteraSub \gets$ Frontera($solucionSub$)              \Comment $O(n^2)$\\

    \State $solucionSuprema \gets solucionSwap$ \Comment $O(1)$
    \State $fronteraSuprema \gets fronteraSwap$ \Comment $O(1)$\\

    \If{$fronteraAdd > fronteraSuprema$}                \Comment $O(1)$
        \State $fronteraSuprema \gets$ $fronteraAdd$    \Comment $O(1)$
        \State $solucionSuprema \gets$ $solucionAdd$    \Comment $O(1)$\\
    \EndIf

    \If{$fronteraSub > fronteraSuprema$}                \Comment $O(1)$
        \State $fronteraSuprema \gets$ $fronteraSub$    \Comment $O(1)$
        \State $solucionSuprema \gets$ $solucionSub$    \Comment $O(1)$\\
    \EndIf

    \State return $solucionSuprema$                     \Comment $O(1)$
\EndFunction

\end{algorithmic}
\end{algorithm}

\todo[inline]{MaximoPorSwap hace tal y tal cosa}

\begin{algorithm}[H]
\begin{algorithmic}
\Function{MaximoPorSwap}{$solucionInicial$, $complementoInicial$}   \Comment $O(n^5)$

    \State $candidatos \gets solucionInicial$
    \State $maxFrontera \gets$ Frontera($solucionInicial$)  \Comment $O(n^2)$
    \State $max\_i \gets -1$                                \Comment $O(1)$
    \State $max\_j \gets -1$                                \Comment $O(1)$\\

    \For{$i \in [0..|solucionInicial|)$}                    \Comment $O(n^5)$ Ver sección Complejidad
        \For{$j \in [0..|complementoInicial|)$}

            \State $candidato$[$i$] $\gets complementoInicial$[$j$] \Comment Hacemos swap $O(1)$

            \If{EsClique($candidatos$)}                                         \Comment $O(n^3)$
                \State $fronteraCandidato \gets$ Frontera($candidato$)          \Comment $O(n^2)$
                \If{$fronteraCandidato > maxFrontera$}                          \Comment $O(1)$
                    \State $max\_i \gets i$                                     \Comment $O(1)$
                    \State $max\_j \gets j$                                     \Comment $O(1)$
                    \State $maxFrontera \gets fronteraCandidato$                \Comment $O(1)$
                \EndIf
            \EndIf

            \State $candidato$[$i$] $\gets solucionInicial$[$j$] \Comment Restauro swap $O(1)$
        \EndFor
    \EndFor

    \If{$max\_i \neq -1$}                           \Comment $O(1)$
        \State $candidato$[$max\_i$] $\gets$ $complementoInicial$[$max\_j$] \Comment Swapeo definitivamente $O(1)$
    \EndIf

    \State return $candidatos$                      \Comment $O(1)$

\EndFunction
\end{algorithmic}
\end{algorithm}

\todo[inline]{MaximoPorSub hace tal y tal cosa}

\begin{algorithm}[H]
\begin{algorithmic}
\Function{MaximoPorSub}{$solucionInicial$}                      \Comment $O(n^4)$
    \State $candidatos \gets solucionInicial$
    \State $maxFrontera \gets$ Frontera($solucionInicial$)      \Comment $O(n^2)$
    \State $max\_c \gets -1$  \\                                \Comment $O(1)$

    \For{$c \in candidatos$}                                                \Comment $O(n^4)$
        \If{EsClique($candidatos - \{c\}$)}                                 \Comment $O(n^3)$
            \State $fronteraCandidato \gets$ Frontera($candidatos - \{c\}$) \Comment $O(n^2)$
            \If{$fronteraCandidato > maxFrontera$}                          \Comment $O(1)$
                \State $max\_c \gets c$                                     \Comment $O(1)$
                \State $maxFrontera \gets fronteraCandidato$                \Comment $O(1)$ \\
            \EndIf
        \EndIf
    \EndFor

    \If{$max\_c \neq -1$}                                           \Comment $O(1)$
        \State $candidatos \gets (candidatos - \{max\_c\})$         \Comment $O(1)$
    \EndIf

    \State return $candidatos$

\EndFunction
\end{algorithmic}
\end{algorithm}

\todo[inline]{MaximoPorAdd hace tal y tal cosa}

\begin{algorithm}[H]
\begin{algorithmic}
\Function{MaximoPorAdd}{$solucionInicial$, $complementoInicial$}        \Comment $O(n^4)$

    \State $maxFrontera \gets$ Frontera($solucionInicial$)              \Comment $O(n^2)$
    \State $max\_c \gets -1$                                            \Comment $O(1)$
    \State $candidatos \gets solucionInicial$                           \Comment $O(1)$\\

    \For{$c \in complementoInicial$}                                            \Comment $O(n^4)$
        \If{EsClique($candidatos + \{c\}$)}                                     \Comment $O(n^3)$
            \State $fronteraCandidato \gets$ Frontera($candidatos + \{c\}$)     \Comment $O(n^2)$
            \If{$fronteraCandidato > maxFrontera$}                              \Comment $O(1)$
                \State $max\_c \gets c$                                         \Comment $O(1)$
                \State $maxFrontera \gets fronteraCandidato$                    \Comment $O(1)$\\
            \EndIf
        \EndIf
    \EndFor

    \If{$max\_c \neq -1$}                                           \Comment $O(1)$
        \State $candidatos \gets (candidatos + \{max\_c\})$         \Comment $O(1)$
    \EndIf

    \State return $candidatos$                      \Comment $O(1)$

\EndFunction
\end{algorithmic}
\end{algorithm}

Para calcular el complemento, armamos un vector de booleanos que dicen si un nodo pertenece o no a la solución input. Luego recorremos el vector y armamos un nuevo vector con aquellos nodos que no estaban en la solución original.

\begin{algorithm}[H]
\begin{algorithmic}
\Function{Complemento}{$solucionInicial$}
    \State $pertenece[i] =$ True $\iff i \in solucionInicial$   \Comment $O(n)$
    \State $complemento \gets \{\}$                             \Comment $O(1)$

    \For{$i \in [0..n)$}                                        \Comment $O(n)$
        \If{$pertenece$[$i$]$ = $True}                          \Comment $O(1)$
            \State $complemento$.PushBack($i$)                  \Comment $O(1)$  amortizado
        \EndIf
    \EndFor

    \State return $complemento$                                 \Comment $O(1)$

\EndFunction
\end{algorithmic}
\end{algorithm}


\subsection{Complejidad}

\todo[inline]{Marcar complejidades en pseudo}
\todo[inline]{Contar brevemente por que la complejidad total es tal}

\subsection{Optimalidad}
\todo[inline]{Contar como con esto mejoramos los peores casos del greedy del punto 2}

\subsection{Experimentación}
\todo[inline]{Hacer comparaciones de fronteras entre soluciones de greedyA y busqueda local, fundamentalmente para los inputs malos}